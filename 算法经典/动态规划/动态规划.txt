动态规划核心思想：把原问题分解成子问题进行求解——分治思想
问题：
1.重叠子问题：不同的问题，可能都要求一个相同问题的解
2.最优子结构
3.无后效性：求出来的子问题并不会因为后面求出来的改变(同贪心算法)

过程：(四步)
1.划分状态:即划分子问题
2.状态表示：即如何让计算机理解子问题
3.状态转移：即父问题怎么由子问题推导出来
4.确定边界：确定初始状态是什么？最小的子问题？最终状态是什么？

实现的套路：
1.自底向上：简单来说就是根据初始状态，逐步推导到最终状态，而这个转移的过程，必定是一个拓扑序。
	自底向上一般用来解决什么问题呢？那就是可以轻松确定拓扑序的问题，例如线性模型，都是从左往右进行转移，
	区间模型，一般都是从小区间推导到大区间。自底向上的一个经典实现是斐波那楔数列的递推实现，即F[i] = F[i - 1] + F[i - 2] 
2.自顶而下：也就是从最终状态出发，如果遇到一个子问题还未求解，那么就先求解子问题。如果子问题已经求解，那么直接使用子问题的解

long getF(int x){
 if(f[x]!=-1){//这个状态没有拓展过
    return f[x];
 return getF(x-1)+getF(x-2);//找到到达这个状态的状态
}


例题：01背包
思路:
1.
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstdio>
using namespace std;
// value数组代表骨头的价值，volume数组代表骨头的体积
int value[1004]={0},volume[1004]={0};
int bp[1004][1004]={0};
int main()
{
    // n是骨头的价值，v
    int n,v,t;//骨头的数量和背包的最大体积
    cin>>t;
    // t代表背包的最大体积
    for(int z=0;z<t;z++)
    {
        cin>>n>>v;
        for(int i=1;i<=n;i++)
        {
            cin>>value[i];//每个骨头的价值
        }
        for(int j=1;j<=n;j++)
        {
            cin>>volume[j];//每个骨头的体积
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<=v;j++)
            {
                if(j<volume[i])
                    bp[i][j]=bp[i-1][j];
                else
                    bp[i][j]=max(bp[i-1][j],bp[i-1][j-volume[i]]+value[i]);
            }
        }
        cout<<bp[n][v]<<endl;
    }
    return 0;
}
